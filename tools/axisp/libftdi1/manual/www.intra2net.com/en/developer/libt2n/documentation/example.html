<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>libt2n: Usage example</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<!-- header start -->

<style> body { margin: 5px 25px 50px 25px; } </style>

<br>
<a href="../../index.html"><img src="../../../../de/pictures/intra2net.gif" alt="Intra2net AG"></a>
<br><br>

<!-- header end -->

<!-- Generated by Doxygen 1.7.4 -->
<div id="top">
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">libt2n&#160;<span id="projectnumber">0.6</span></div>
  </td>
 </tr>
 </tbody>
</table>
</div>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li class="current"><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li><a href="dirs.html"><span>Directories</span></a></li>
    </ul>
  </div>
</div>
<div class="header">
  <div class="headertitle">
<div class="title">Usage example </div>  </div>
</div>
<div class="contents">
<div class="textblock"><p>In this example we create two packages using the autotools:</p>
<ul>
<li>server program and client library to connect to the server. The server exports a simple procedure using one group: "t2nexample"</li>
<li>client program using the library</li>
</ul>
<h2><a class="anchor" id="server"></a>
Example server program and client library</h2>
<dl class="user"><dt><b>The procedure to export (input for the code generator - libt2n-codegen): t2nexample.cpp:</b></dt><dd>First the procedure to export is defined. It is marked for export with the attribute macro <a class="el" href="codegen-stubhead_8hxx.html#ad8a6256cdfdf7b5e52715cfefd453ef4">LIBT2N_EXPORT</a>. In this example the procedure throws an exception if the input string is "throw". The exception is passed back to the client transparently. Otherwise some text is appended and returned. <div class="fragment"><pre class="fragment"><span class="comment">// include automatically generated code</span>
<span class="preprocessor">#include &quot;t2nexample_common.hxx&quot;</span>

<a class="code" href="codegen-stubhead_8hxx.html#ad8a6256cdfdf7b5e52715cfefd453ef4" title="mark a function to export it via libt2n">LIBT2N_EXPORT</a> std::string testfunc(std::string str) 
{
    <span class="comment">// exceptions derived from libt2n::t2n_exception are passed to the client transparently</span>
    <span class="keywordflow">if</span> (str==<span class="stringliteral">&quot;throw&quot;</span>)
        <span class="keywordflow">throw</span> <a class="code" href="classlibt2n_1_1t2n__runtime__error.html" title="a runtime error within the remote function. derive your own custom exceptions from this one...">libt2n::t2n_runtime_error</a>(<span class="stringliteral">&quot;throw me around&quot;</span>);
    <span class="keywordflow">return</span> str+<span class="stringliteral">&quot;, testfunc() was here&quot;</span>;
}
</pre></div></dd></dl>
<dl class="user"><dt><b>Required includes go into the group header file: t2nexample.hxx:</b></dt><dd>All includes required to get the declarations of the types used by the procedures to export go into the group header file. <a class="el" href="namespacelibt2n.html">libt2n</a> uses boost for serialization. This means all types involved in a remote procedure call must be boost serializable. In this example we only use std::string provided by &lt;string&gt; and boost already provides serialization for std::string in the boost/serialization/string.hpp header file. <div class="fragment"><pre class="fragment"><span class="preprocessor">#include &lt;string&gt;</span>
<span class="preprocessor">#include &lt;boost/serialization/string.hpp&gt;</span>
</pre></div></dd></dl>
<dl class="user"><dt><b>The server program: server.cpp:</b></dt><dd>We have to provide the main entry point for the server program. In this example we use a local socket and the server program simply waits until a request is received which then is handled by the generated code directly. We use a <a class="el" href="classlibt2n_1_1group__command__server.html">libt2n::group_command_server</a> to handle the requests. Each <a class="el" href="classlibt2n_1_1group__command__server.html">libt2n::group_command_server</a> is tied to one command group. Which source file exports it's functions into which command group is defined in the Makefile (see below). <div class="fragment"><pre class="fragment"><span class="preprocessor">#include &lt;signal.h&gt;</span> 

<span class="preprocessor">#include &lt;<a class="code" href="socket__server_8hxx.html">socket_server.hxx</a>&gt;</span>
<span class="preprocessor">#include &lt;<a class="code" href="command__server_8hxx.html">command_server.hxx</a>&gt;</span> <span class="comment">// for group_command_server</span>

<span class="comment">// the automatically generated server side code (cmd_group_t2nexample class)</span>
<span class="preprocessor">#include &quot;t2nexample_server.hxx&quot;</span>

<span class="keywordtype">int</span> main(<span class="keywordtype">int</span> argc, <span class="keywordtype">char</span>** argv)
{
    <span class="comment">// don&#39;t kill the server on broken pipe</span>
    signal(SIGPIPE, SIG_IGN);

    <span class="comment">// create local socket server (a.k.a &quot;unix domain socket&quot;)</span>
    <span class="comment">// if you want to to create a tcp/ip server you pass the port to the constructor</span>
    <span class="comment">// (for details take a look at the socket_server class documentation)</span>
    <a class="code" href="classlibt2n_1_1socket__server.html" title="Socket based server class.">libt2n::socket_server</a> ss(<span class="stringliteral">&quot;./socket&quot;</span>);
    <a class="code" href="classlibt2n_1_1group__command__server.html" title="server handling group of incoming commands">libt2n::group_command_server&lt;cmd_group_t2nexample&gt;</a> cs(ss);

    <span class="comment">// handle requests</span>
    <span class="keywordflow">while</span>(<span class="keyword">true</span>)
        cs.handle();

    <span class="keywordflow">return</span> 0;
}
</pre></div></dd></dl>
<dl class="user"><dt><b>Using autoconf and automake to build a example server program and a client library.</b></dt><dd>In the configure.in(.ac) we check for <a class="el" href="namespacelibt2n.html">libt2n</a> using the LIBT2N_CHECK m4 macro provided by <a class="el" href="namespacelibt2n.html">libt2n</a>. <div class="fragment"><pre class="fragment">AC_INIT(configure.in)
AM_INIT_AUTOMAKE(libt2n-example1, 0.1)
AC_LANG_CPLUSPLUS
AC_PROG_CXX
AM_PROG_LIBTOOL

dnl check for libt2n (library and code generator)
LIBT2N_CHECK(libt2n &gt;= 0.2)

AC_OUTPUT(Makefile)
</pre></div> Writing the Makefile.am isn't difficult either. We have to list the command groups used. For each command group we have to list the C++ source files with the procedures to export. For each group we build a client library by listing the generated client code (group_client.cpp) in a corresponding libtool library target. The .pc file for the library is generated automatically. The sources of the server program must include the generated server code (group_server.cpp), the file with the main entry point and of course the procedure definition. <div class="fragment"><pre class="fragment"># not a GNU package. You can remove this line, if you have all needed files, that a GNU package needs
AUTOMAKE_OPTIONS = foreign

# our dependencies
INCLUDES = @LIBT2N_CFLAGS@
LDADD = @LIBT2N_LIBS@

# list your command groups (seperated by spaces)
CMDGROUPS = t2nexample

# for each command group list the files to parse for LIBT2N_EXPORT
t2nexample_GROUP = t2nexample.cpp

# unfortunately we can't set those from variables (because they are parsed by automake)

# for each group build a client library from generated source file(s)
# (if you have automake &gt;= 1.5 you might wish to use nodist_ here)
# Note: the library name must match the group name
libt2nexample_la_SOURCES = t2nexample_client.cpp
lib_LTLIBRARIES = libt2nexample.la

# build server program
bin_PROGRAMS = libt2n-example1-server

# (if you have automake &gt;= 1.5 you might wish to use nodist_ here)
# nodist_server_SOURCES = t2nexample_server.cpp

libt2n_example1_server_SOURCES = \
	server.cpp $(t2nexample_GROUP) \
	t2nexample_server.cpp

# Make libt2n-gccxml.sh available
# as libt2n is not installed yet
PATH := $(top_srcdir):$(PATH)

# include Makefile snippet doing all the magic
include codegen.make
</pre></div></dd></dl>
<dl class="user"><dt><b>Build and install the package</b></dt><dd>To build and install the package we first have to create the configure script and the other help scripts of the autotools by running autoreconf. <div class="fragment"><pre class="fragment">
 autoreconf -f -i &amp;&amp; ./configure &amp;&amp; make install
 </pre></div></dd></dl>
<h2><a class="anchor" id="client"></a>
Client using the library</h2>
<p>Using the library is as simple as using any other library using pkg-config (the pkg-config .pc file is created automatically by the included Makefile snippet) </p>
<dl class="user"><dt><b>We only have to check that the library is installed</b></dt><dd><div class="fragment"><pre class="fragment">AC_INIT(configure.in)
AM_INIT_AUTOMAKE(libt2n-example1-client, 0.1)
AC_LANG_CPLUSPLUS
AC_PROG_CXX
AM_PROG_LIBTOOL

dnl check for the client library
PKG_CHECK_MODULES(T2NEXAMPLE, t2nexample = 0.1)

AC_OUTPUT(Makefile)
</pre></div> </dd></dl>
<dl class="user"><dt><b>The Makefile.am needs nothing special</b></dt><dd><div class="fragment"><pre class="fragment"># not a GNU package. You can remove this line, if you have all needed files, that a GNU package needs
AUTOMAKE_OPTIONS = foreign
INCLUDES = @T2NEXAMPLE_CFLAGS@
LDADD = @T2NEXAMPLE_LIBS@
bin_PROGRAMS = libt2n-example1-client
libt2n_example1_client_SOURCES = client.cpp
</pre></div> </dd></dl>
<dl class="user"><dt><b>The client program: client.cpp:</b></dt><dd>The example client first connects to the local socket. The connection is passed to the constructor of the generated class. To call the remote procedure the "testfunc" method is called. The example first passes "throw" to the remote procedure which will result in a exception to be thrown which is passed back to the client and thrown on the client side again. In the example the exception is caught and it is checked whether the string returned by what() is correct. If so a second remote procedure call is made and its return value is checked. Only if both tests succeed the program will exit with a status value indicating success. <div class="fragment"><pre class="fragment"><span class="comment">// for socket_client_connection</span>
<span class="preprocessor">#include &lt;<a class="code" href="socket__client_8hxx.html">socket_client.hxx</a>&gt;</span>

<span class="comment">// include generated library header</span>
<span class="preprocessor">#include &quot;t2nexample_client.hxx&quot;</span>

<span class="keywordtype">int</span> main(<span class="keywordtype">int</span> argc, <span class="keywordtype">char</span>** argv)
{
    <span class="comment">// use a local socket (a.k.a &quot;unix domain socket&quot;)</span>
    <span class="comment">// if you want to connect to a tcp/ip server you pass the port and server name to the constructor</span>
    <a class="code" href="classlibt2n_1_1socket__client__connection.html" title="a connection from client to server using sockets.">libt2n::socket_client_connection</a> sc(<span class="stringliteral">&quot;./socket&quot;</span>);
    <span class="comment">// this generated class has a method for each of our exported procedures</span>
    cmd_group_t2nexample_client cc(&amp;sc);

    <span class="keywordtype">bool</span> throwok=<span class="keyword">false</span>;

    <span class="comment">// exceptions are passed back to the client transparently</span>
    <span class="keywordflow">try</span>
    {
        <span class="comment">// call the remote procedure (we pass &quot;throw&quot; to cause a exception to be thrown)</span>
        cc.testfunc(<span class="stringliteral">&quot;throw&quot;</span>);
    }
    <span class="keywordflow">catch</span>(<a class="code" href="classlibt2n_1_1t2n__runtime__error.html" title="a runtime error within the remote function. derive your own custom exceptions from this one...">libt2n::t2n_runtime_error</a> &amp;e)
    {
        throwok=(std::string(e.<a class="code" href="classlibt2n_1_1t2n__exception.html#a9088a537788292a2deb615f7858851b9">what</a>())==<span class="stringliteral">&quot;throw me around&quot;</span>);
    }

    <span class="comment">// call remote procedure and check the return value is correct</span>
    <span class="keywordflow">return</span> ( throwok &amp;&amp; ( cc.testfunc(<span class="stringliteral">&quot;hello&quot;</span>) == <span class="stringliteral">&quot;hello, testfunc() was here&quot;</span> ) )
        ? EXIT_SUCCESS : EXIT_FAILURE;
}
</pre></div></dd></dl>
<dl class="user"><dt><b>Build and install the package</b></dt><dd><div class="fragment"><pre class="fragment">
 autoreconf -f -i &amp;&amp; ./configure &amp;&amp; make install
 </pre></div></dd></dl>
<dl class="user"><dt><b>Test</b></dt><dd>To test whether it works we first start the server that creates a socket 'socket' in the current working directory. Then we run the client and print "ok" if it exited with a status value indicating success. <div class="fragment"><pre class="fragment">
$ cd /tmp
$ file socket
socket: cannot open `socket' (No such file or directory)
$ libt2n-example1-server &amp;
[1] 7711
$ file socket
socket: socket
$ libt2n-example1-client &amp;&amp; echo ok
ok
$ kill %1
$ rm socket
 </pre></div></dd></dl>
<h2><a class="anchor" id="wrapper"></a>
The Client-Wrapper</h2>
<p>The interfaces can be called directly in the way outlined above. But this means you have to take care of connection errors between client and server at each call, possibly try to reconnect and so on. Libt2n provides the Client-Wrapper to ease this. It is a way to select a error handling strategy once and use it automatically for all calls invoked through the Wrapper. Tough error-handling is the common usecase, the Client-Wrapper could be used to execute any user-provided code before and after a call to the server is made.</p>
<p>The other feature that the Client-Wrapper provides is a connection-singleton. T2n (currently) only offers single-threaded servers. So if you use methods of a T2n-server in a program, you usually only want to maintain one common connection to this server - even if it is accessed from different parts/modules/classes/... of your program. The Client-Wrapper is initialized with a <a class="el" href="classlibt2n_1_1ConnectionWrapper.html">libt2n::ConnectionWrapper</a>.</p>
<p>This <a class="el" href="classlibt2n_1_1ConnectionWrapper.html">libt2n::ConnectionWrapper</a> takes the error-handling strategy (e.g. reconnect-then-throw) and everything needed to establish a connection (e.g. socket name or host and tcp-port) as parameters. A connection is established at the first actual request to the server and re-used for following requests. You don't need to pass around client-handles and the like to your classes or methods, finding the right wrapper is done via the global singleton created for each server-interface initialized for the wrapper.</p>
<p>This example shows how to use the Client-Wrapper:</p>
<div class="fragment"><pre class="fragment"><span class="comment">// for a wrapped socket connection</span>
<span class="preprocessor">#include &lt;<a class="code" href="socket__wrapper_8hxx.html">socket_wrapper.hxx</a>&gt;</span>

<span class="comment">// include generated library header</span>
<span class="preprocessor">#include &quot;t2nexample_client.hxx&quot;</span>

<span class="comment">// define a type for more conveniant access</span>
<span class="keyword">typedef</span> <a class="code" href="classlibt2n_1_1T2nSingletonWrapper.html" title="wrap calls to server-side-functions with different error-handling strategies">libt2n::T2nSingletonWrapper&lt;cmd_group_t2nexample_client&gt;</a> wraptype;

<span class="comment">// static object which keeps the wrapper-singleton</span>
<span class="keyword">template</span>&lt;&gt;
std::auto_ptr&lt;wraptype&gt; wraptype::SingletonObject = std::auto_ptr&lt;wraptype&gt;();

<span class="comment">// static object which keeps the connection</span>
<span class="keyword">template</span>&lt;&gt;
std::auto_ptr&lt;libt2n::ConnectionWrapper&gt; wraptype::WrappedConnection =
    std::auto_ptr&lt;libt2n::ConnectionWrapper&gt;();

<span class="keywordtype">int</span> main(<span class="keywordtype">int</span> argc, <span class="keywordtype">char</span>** argv)
{
    <span class="comment">// tell the client-wrapper how to contact the server if a connection is requested</span>
    wraptype::set_connection(std::auto_ptr&lt;libt2n::ConnectionWrapper&gt;
        (<span class="keyword">new</span> <a class="code" href="classlibt2n_1_1ReconnectSocketWrapper.html" title="a wrapper implementing reconnect-then-throw">libt2n::ReconnectSocketWrapper</a>(<span class="stringliteral">&quot;./socket&quot;</span>)));

    <span class="comment">// execute a function via t2n. The wrapper will open a connection to the server if none</span>
    <span class="comment">// exists or try to reconnect if the existing one doesn&#39;t answer</span>
    std::cout &lt;&lt; t2n_exec(&amp;cmd_group_t2nexample_client::testfunc)(<span class="stringliteral">&quot;hello&quot;</span>) &lt;&lt; std::endl;

    <span class="keywordflow">return</span> EXIT_SUCCESS;
}
</pre></div><p>The details of the Client-Wrapper can be found in the <a class="el" href="classlibt2n_1_1T2nSingletonWrapper.html">libt2n::T2nSingletonWrapper</a>, but beware, the code is full of ugly templates and template-construction-defines. </p>
</div></div>
<hr class="footer"/><address class="footer"><small>Generated on Fri May 20 2011 for libt2n by&#160;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.7.4 </small></address>

<!-- footer start -->

&copy; Intra2net AG 2015 | <a href="../../../imprint.php">Imprint</a> | <a href="../../../contact/index.html">Contact</a>

<!-- footer end -->
</body>
</html>
